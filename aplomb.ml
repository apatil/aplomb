module type DataS = sig

  (** The type that holds the dataset. *)
  type t

  (**
  The type of references to fields (columns) in the dataset. If the dataset is a
  map, this should be the key type. If this module is generated from a record type
  by ppx_deriving_aplomb, this will be a variant type whose values correspond to
  field names of the record.
  *)

  type field

  (** A function that maps the dataset to a list of Yojson objects. *)
  val inline : t -> VegaLite.V2.Data.t

  (**
  A function that evaluates to the name of a field as a string. This name should
  correspond to the keys in the Yojson spec generated by 'inline'.
  *)
  val fieldName : field -> string

  (**
  A function that evaluates to the Vega-Lite type of a field. This may be one of
  `Ordinal, `Nominal, `Temporal or `Quantitative. It may be overridden when
  generating plots.
  *)
  val defaultTyp : field -> VegaLite.V2.Type.t
end

module type AplombS = sig
  open VegaLite.V2
  module Data : DataS

  val field : Data.field -> Field.t

  val fieldDef :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    [`Field of FieldDef.t | `Value of ValueDef.t]

  type repeat = {
    column : Data.field list;
    row : Data.field list;
  }

  val positionFieldDef :
    ?aggregate:AggregateOp.t ->
    ?axis:Axis.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?stack:StackOffset.t ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    [`Field of PositionFieldDef.t | `Value of ValueDef.t]

  val conditionalLegendFieldDef :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    [`Field of ConditionalLegendFieldDef.t | `Value of ConditionalLegendValueDef.t]

  val conditionalTextFieldDef :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?format:string ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    [`Field of ConditionalTextFieldDef.t | `Value of ConditionalTextValueDef.t]

  val orderFieldDef :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?sort:SortOrder.t ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    [`Field of OrderFieldDef.t | `Fields of OrderFieldDef.t list]

  val conditionLegendFieldDef :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    selection:SelectionOperand.t ->
    Data.field ->
    [`Field of ConditionLegendFieldDef.t | `Value of ConditionValueDef.t]

  val conditionTextFieldDef :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?format:string ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    selection:SelectionOperand.t ->
    Data.field ->
    [`Field of ConditionTextFieldDef.t | `Value of ConditionValueDef.t]

  val facetFieldDef :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?header:Header.t ->
    ?sort:SortOrder.t ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    FacetFieldDef.t

  val legendFieldDef :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    LegendFieldDef.t

  val scaleFieldDef :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    ScaleFieldDef.t

  val orderFieldDef :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?sort:SortOrder.t ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    OrderFieldDef.t

  (* Types for encoding fields *)
  val legendCondition :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    selection:SelectionOperand.t ->
    Data.field ->
    [ `Field of ConditionLegendFieldDef.t | `Value of ConditionValueDef.t ]

  val textCondition :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?format:string ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    selection:SelectionOperand.t ->
    Data.field ->
    [ `Field of ConditionTextFieldDef.t | `Value of ConditionValueDef.t ]

  val sort :
    ?order:SortOrder.t ->
    op:AggregateOp.t ->
    Data.field ->
    [ `Field of SortField.t | `Order of SortOrder.t ]

  val x :
    ?aggregate:AggregateOp.t ->
    ?axis:Axis.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?stack:StackOffset.t ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    Spec.t -> Spec.t

  val xRep :
    ?aggregate:AggregateOp.t ->
    ?axis:Axis.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?stack:StackOffset.t ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  val xVal :
    [ `Int of int | `Float of float | `Bool of bool | `String of string ] ->
    Spec.t -> Spec.t

  val y :
    ?aggregate:AggregateOp.t ->
    ?axis:Axis.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?stack:StackOffset.t ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    Spec.t -> Spec.t

  val yRep :
    ?aggregate:AggregateOp.t ->
    ?axis:Axis.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?stack:StackOffset.t ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  val yVal :
    [ `Int of int | `Float of float | `Bool of bool | `String of string ] ->
    Spec.t -> Spec.t

  val x2 :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    Spec.t -> Spec.t

  val x2Rep :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  val x2Val :
    [ `Int of int | `Float of float | `Bool of bool | `String of string ] ->
    Spec.t -> Spec.t

  val y2 :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    Spec.t -> Spec.t

  val y2Rep :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  val y2Val :
    [ `Int of int | `Float of float | `Bool of bool | `String of string ] ->
    Spec.t -> Spec.t

  val size :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    Spec.t -> Spec.t

  val sizeRep :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  val sizeVal :
    ?condition:[ `Field of ConditionLegendFieldDef.t | `Value of ConditionValueDef.t ] ->
    ?value:[ `Int of int | `Float of float | `Bool of bool | `String of string ] ->
    Spec.t -> Spec.t

  val shape :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    Spec.t -> Spec.t

  val shapeRep :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  val shapeVal :
    ?condition:[ `Field of ConditionLegendFieldDef.t | `Value of ConditionValueDef.t ] ->
    ?value:[ `Int of int | `Float of float | `Bool of bool | `String of string ] ->
    Spec.t -> Spec.t

  val opacity :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    Spec.t -> Spec.t

  val opacityRep :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  val opacityVal :
    ?condition:[ `Field of ConditionLegendFieldDef.t | `Value of ConditionValueDef.t ] ->
    ?value:[ `Int of int | `Float of float | `Bool of bool | `String of string ] ->
    Spec.t -> Spec.t

  val color :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    Spec.t -> Spec.t

  val colorRep :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  val colorVal :
    ?condition:[ `Field of ConditionLegendFieldDef.t | `Value of ConditionValueDef.t ] ->
    ?value:[ `Int of int | `Float of float | `Bool of bool | `String of string ] ->
    Spec.t -> Spec.t

  val tooltip :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?format:string ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    Spec.t -> Spec.t

  val tooltipRep :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?format:string ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  val tooltipVal :
    ?condition:[ `Field of ConditionTextFieldDef.t | `Value of ConditionValueDef.t ] ->
    ?value:[ `Int of int | `Float of float | `Bool of bool | `String of string ] ->
    Spec.t -> Spec.t

  val text :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?format:string ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    Spec.t -> Spec.t

  val textRep :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?format:string ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  val textVal :
    ?condition:[ `Field of ConditionTextFieldDef.t | `Value of ConditionValueDef.t ] ->
    ?value:[ `Int of int | `Float of float | `Bool of bool | `String of string ] ->
    Spec.t -> Spec.t

  val order :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?sort:SortOrder.t ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    Spec.t -> Spec.t

  val orderMulti :
    OrderFieldDef.t list ->
    Spec.t -> Spec.t

  val detail :
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    Data.field ->
    Spec.t -> Spec.t

  val detailMulti :
    FieldDef.t list ->
    Spec.t -> Spec.t



  (* For generating specs *)
  val unitSpec :
    ?description:string ->
    ?height:[ `Float of float | `Int of int ] ->
    ?name:string ->
    ?selection:(string * SelectionDef.t) list ->
    ?title:[ `Params of TitleParams.t | `String of string ] ->
    ?transform:Transform.t list ->
    ?width:[ `Float of float | `Int of int ] ->
    ?encoding:Encoding.t ->
    ?data:(Data.t) ->
    AnyMark.t ->
    CompositeUnitSpec.t

  val layerSpec :
    ?description:string ->
    ?height:[ `Float of float | `Int of int ] ->
    ?name:string ->
    ?resolve:Resolve.t ->
    ?title:[ `Params of TitleParams.t | `String of string ] ->
    ?transform:Transform.t list ->
    ?width:[ `Float of float | `Int of int ] ->
    ?data:(Data.t) ->
    [ `Layer of LayerSpec.t | `Unit of CompositeUnitSpec.t ] list ->
    LayerSpec.t

  val faceted :
    ?description:string ->
    ?name:string ->
    ?resolve:Resolve.t ->
    ?title:[ `Params of TitleParams.t | `String of string ] ->
    ?transform:Transform.t list ->
    ?data:(Data.t) ->
    facet:Facet.t ->
    [ `Layer of LayerSpec.t | `Unit of CompositeUnitSpec.t ] ->
    Spec.t

  val hconcat :
    ?description:string ->
    ?name:string ->
    ?resolve:Resolve.t ->
    ?title:[ `Params of TitleParams.t | `String of string ] ->
    ?transform:Transform.t list ->
    ?data:(Data.t) ->
    Spec.t list ->
    Spec.t

  val vconcat :
    ?description:string ->
    ?name:string ->
    ?resolve:Resolve.t ->
    ?title:[ `Params of TitleParams.t | `String of string ] ->
    ?transform:Transform.t list ->
    ?data:(Data.t) ->
    Spec.t list ->
    Spec.t

  val repeat :
    ?description:string ->
    ?name:string ->
    ?resolve:Resolve.t ->
    ?title:[ `Params of TitleParams.t | `String of string ] ->
    ?transform:Transform.t list ->
    ?data:(Data.t) ->
    repeat:repeat ->
    Spec.t ->
    Spec.t

  val simple :
    ?description:string ->
    ?height:[ `Float of float | `Int of int ] ->
    ?name:string ->
    ?selection:(string * SelectionDef.t) list ->
    ?title:[ `Params of TitleParams.t | `String of string ] ->
    ?transform:Transform.t list ->
    ?width:[ `Float of float | `Int of int ] ->
    ?encoding:Encoding.t ->
    ?data:(Data.t) ->
    AnyMark.t ->
    Spec.t

  val layer :
    ?description:string ->
    ?height:[ `Float of float | `Int of int ] ->
    ?name:string ->
    ?resolve:Resolve.t ->
    ?title:[ `Params of TitleParams.t | `String of string ] ->
    ?transform:Transform.t list ->
    ?width:[ `Float of float | `Int of int ] ->
    ?data:(Data.t) ->
    [ `Layer of LayerSpec.t | `Unit of CompositeUnitSpec.t ] list ->
    Spec.t

  val finish :
    ?padding:Padding.t ->
    ?config:Config.t ->
    ?background:string ->
    ?autoResize:bool ->
    ?rowFacet:FacetFieldDef.t ->
    ?columnFacet:FacetFieldDef.t ->
    Spec.t -> TopLevelExtendedSpec.t
end

module Make (D : DataS) : (AplombS with module Data = D) = struct
  open VegaLite.V2
  module Data = D

  (* Types for building blocks of encodings based on concrete fields *)

  let field x = `String (D.fieldName x)

  let inferTyp typ_ field =
    match typ_ with
    | Some tp -> tp
    | None -> (D.defaultTyp field)

  let repeatField x =
    match x with
    | `Row -> (`Repeat (`Row))
    | `Column -> (`Repeat (`Column))


  type repeat = {
    column : D.field list;
    row : D.field list;
  }

  let fieldDef ?aggregate ?bin ?timeUnit ?typ x =
    `Field (FieldDef.make
      ?aggregate
      ?bin
      ?timeUnit
      ~typ:(inferTyp typ x)
      ~field:(field x)
      ())

  let positionFieldDef ?aggregate ?axis ?bin ?scale ?sort ?stack ?timeUnit ?typ x =
    `Field (PositionFieldDef.make
      ?aggregate
      ?axis
      ?bin
      ?scale
      ?sort
      ?stack
      ?timeUnit
      ~typ:(inferTyp typ x)
      ~field:(field x)
      ())

  let conditionalLegendFieldDef ?aggregate ?bin ?condition ?legend ?scale ?sort ?timeUnit ?typ x =
    `Field (ConditionalLegendFieldDef.make
      ?aggregate
      ?bin
      ?condition
      ?legend
      ?scale
      ?sort
      ?timeUnit
      ~typ:(inferTyp typ x)
      ~field:(field x)
      ())

  let conditionalTextFieldDef ?aggregate ?bin ?condition ?format ?timeUnit ?typ x =
    `Field (ConditionalTextFieldDef.make
      ?aggregate
      ?bin
      ?condition
      ?format
      ?timeUnit
      ~typ:(inferTyp typ x)
      ~field:(field x)
      ())

  let orderFieldDef ?aggregate ?bin ?sort ?timeUnit ?typ x =
    OrderFieldDef.make
      ?aggregate
      ?bin
      ?sort
      ?timeUnit
      ~typ:(inferTyp typ x)
      ~field:(field x)
      ()

  let conditionLegendFieldDef ?aggregate ?bin ?legend ?scale ?sort ?timeUnit ?typ ~selection x =
    `Field (ConditionLegendFieldDef.make
      ?aggregate
      ?bin
      ?legend
      ?scale
      ?sort
      ?timeUnit
      ~typ:(inferTyp typ x)
      ~selection
      ~field:(field x)
      ())

  let conditionTextFieldDef ?aggregate ?bin ?format ?timeUnit ?typ ~selection x =
    `Field (ConditionTextFieldDef.make
      ?aggregate
      ?bin
      ?format
      ?timeUnit
      ~typ:(inferTyp typ x)
      ~selection
      ~field:(field x)
      ())

  let facetFieldDef ?aggregate ?bin ?header ?sort ?timeUnit ?typ x =
    FacetFieldDef.make
      ?aggregate
      ?bin
      ?header
      ?sort
      ?timeUnit
      ~typ:(inferTyp typ x)
      ~field:(field x)
      ()

  let legendFieldDef ?aggregate ?bin ?legend ?scale ?sort ?timeUnit ?typ x =
    LegendFieldDef.make
      ?aggregate
      ?bin
      ?legend
      ?scale
      ?sort
      ?timeUnit
      ~typ:(inferTyp typ x)
      ~field:(field x)
      ()

  let scaleFieldDef ?aggregate ?bin ?scale ?sort ?timeUnit ?typ x =
    ScaleFieldDef.make
      ?aggregate
      ?bin
      ?scale
      ?sort
      ?timeUnit
      ~typ:(inferTyp typ x)
      ~field:(field x)
      ()

  let orderFieldDef ?aggregate ?bin ?sort ?timeUnit ?typ x =
    OrderFieldDef.make
      ?aggregate
      ?bin
      ?sort
      ?timeUnit
      ~typ:(inferTyp typ x)
      ~field:(field x)
      ()

  let legendCondition ?aggregate ?bin ?legend ?scale ?sort ?timeUnit ?typ ~selection x =
    (conditionLegendFieldDef ?aggregate ?bin ?legend ?scale ?sort ?timeUnit ?typ ~selection x)

  let textCondition ?aggregate ?bin ?format ?timeUnit ?typ ~selection x =
    (conditionTextFieldDef ?aggregate ?bin ?format ?timeUnit ?typ ~selection x)

  let sort ?order ~op x =
    `Field (SortField.make
              ?order
              ~op
              ~field:(D.fieldName x)
              ())

  let rec specSet (f : Encoding.t -> Encoding.t) (spec : Spec.t) : Spec.t =
    match spec with
    | `Unit s -> `Unit CompositeUnitSpec.{s with encoding=(f s.encoding)}
    | `Repeat s -> `Repeat RepeatSpec.{s with spec = specSet f s.spec}
    | `Faceted s -> `Faceted FacetedSpec.{s with spec = specSetLayer f s.spec}
    | `Layer s -> `Layer LayerSpec.{s with layer = List.map (specSetLayer f) s.layer}
    | `HConcat s -> `HConcat HConcatSpec.{s with hconcat = List.map (specSet f) s.hconcat}
    | `VConcat s -> `VConcat VConcatSpec.{s with vconcat = List.map (specSet f) s.vconcat}

  and specSetLayer (f : Encoding.t -> Encoding.t) (spec : [`Layer of LayerSpec.t | `Unit of CompositeUnitSpec.t]) =
    match spec with
    | `Layer s -> `Layer LayerSpec.{s with layer = List.map (specSetLayer f) s.layer}
    | `Unit s -> `Unit CompositeUnitSpec.{s with encoding=(f s.encoding)}



  (* Note, encodingWithFacet only occurs in TopLevelFacetedUnitSpec . Pull it out of '.facet' during finalize.*)
  type pfdSetter =
    ?aggregate:AggregateOp.t ->
    ?axis:Axis.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?stack:StackOffset.t ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    D.field ->
    Spec.t -> Spec.t

  type pfdRepSetter =
    ?aggregate:AggregateOp.t ->
    ?axis:Axis.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?stack:StackOffset.t ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  let pfdSet (f : [`Field of PositionFieldDef.t | `Value of ValueDef.t] -> Encoding.t -> Encoding.t) : pfdSetter =
    fun ?aggregate ?axis ?bin ?scale ?sort ?stack ?timeUnit ?typ x spec ->
      let pfd = positionFieldDef ?aggregate ?axis ?bin ?scale ?sort ?stack ?timeUnit ?typ x in
      specSet (f pfd) spec

  let pfdSetRep (f : [`Field of PositionFieldDef.t | `Value of ValueDef.t] -> Encoding.t -> Encoding.t) : pfdRepSetter =
    fun ?aggregate ?axis ?bin ?scale ?sort ?stack ?timeUnit ~typ x spec ->
      let pfd = `Field (PositionFieldDef.make ?aggregate ?axis ?bin ?scale ?sort ?stack ?timeUnit ~typ ~field:(`Repeat x) ()) in
      specSet (f pfd) spec

  let x =
    let setter pfd e = Encoding.{e with x = Some pfd} in
    pfdSet setter

  let xRep =
    let setter pfd e = Encoding.{e with x = Some pfd} in
    pfdSetRep setter

  let xVal v spec =
    let f enc = Encoding.{enc with x = Some (`Value v)} in
    specSet f spec

  let y =
    let setter pfd e = Encoding.{e with y = Some pfd} in
    pfdSet setter

  let yRep =
    let setter pfd e = Encoding.{e with y = Some pfd} in
    pfdSetRep setter

  let yVal v spec =
    let f enc = Encoding.{enc with y = Some (`Value v)} in
    specSet f spec


  type fdSetter =
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    D.field ->
    Spec.t -> Spec.t

  type fdRepSetter =
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  let fdSet (f : [`Field of FieldDef.t | `Value of ValueDef.t] -> Encoding.t -> Encoding.t) : fdSetter =
    fun ?aggregate ?bin ?timeUnit ?typ x spec ->
      let fd = fieldDef ?aggregate ?bin ?timeUnit ?typ x in
      specSet (f fd) spec

  let fdSetRep (f : [`Field of FieldDef.t | `Value of ValueDef.t] -> Encoding.t -> Encoding.t) : fdRepSetter =
    fun ?aggregate ?bin ?timeUnit ~typ x spec ->
      let fd = `Field (FieldDef.make ?aggregate ?bin ?timeUnit ~typ ~field:(`Repeat x) ()) in
      specSet (f fd) spec

  let x2 =
    let setter fd e = Encoding.{e with x2 = Some fd} in
    fdSet setter

  let x2Rep =
    let setter fd e = Encoding.{e with x2 = Some fd} in
    fdSetRep setter

  let x2Val v spec =
    let f enc = Encoding.{enc with x2 = Some (`Value v)} in
    specSet f spec

  let y2 =
    let setter fd e = Encoding.{e with x2 = Some fd} in
    fdSet setter

  let y2Rep =
    let setter fd e = Encoding.{e with x2 = Some fd} in
    fdSetRep setter

  let y2Val v spec =
    let f enc = Encoding.{enc with y2 = Some (`Value v)} in
    specSet f spec


  type clfdSetter =
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    D.field ->
    Spec.t -> Spec.t

  type clfdRepSetter =
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?legend:Legend.t ->
    ?scale:Scale.t ->
    ?sort:[ `Field of SortField.t | `Order of SortOrder.t ] ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  let clfdSet (f : [`Field of ConditionalLegendFieldDef.t | `Value of ConditionalLegendValueDef.t] -> Encoding.t -> Encoding.t) : clfdSetter =
    fun ?aggregate ?bin ?condition ?legend ?scale ?sort ?timeUnit ?typ x spec ->
      let clfd = conditionalLegendFieldDef ?aggregate ?bin ?condition ?legend ?scale ?sort ?timeUnit ?typ x in
      specSet (f clfd) spec

  let clfdSetRep (f : [`Field of ConditionalLegendFieldDef.t | `Value of ConditionalLegendValueDef.t] -> Encoding.t -> Encoding.t) : clfdRepSetter =
    fun ?aggregate ?bin ?condition ?legend ?scale ?sort ?timeUnit ~typ x spec ->
      let clfd = `Field (ConditionalLegendFieldDef.make ?aggregate ?bin ?condition ?legend ?scale ?sort ?timeUnit ~typ ~field:(`Repeat x) ()) in
      specSet (f clfd) spec

  let size =
    let setter clfd e = Encoding.{e with size = Some clfd} in
    clfdSet setter

  let sizeRep =
    let setter clfd e = Encoding.{e with size = Some clfd} in
    clfdSetRep setter

  let sizeVal ?condition ?value spec =
    let v = ConditionalLegendValueDef.make ?condition ?value () in
    let f enc = Encoding.{enc with size = Some (`Value v)} in
    specSet f spec

  let shape =
    let setter clfd e = Encoding.{e with shape = Some clfd} in
    clfdSet setter

  let shapeRep =
    let setter clfd e = Encoding.{e with shape = Some clfd} in
    clfdSetRep setter

  let shapeVal ?condition ?value spec =
    let v = ConditionalLegendValueDef.make ?condition ?value () in
    let f enc = Encoding.{enc with shape = Some (`Value v)} in
    specSet f spec

  let opacity =
    let setter clfd e = Encoding.{e with opacity = Some clfd} in
    clfdSet setter

  let opacityRep =
    let setter clfd e = Encoding.{e with opacity = Some clfd} in
    clfdSetRep setter

  let opacityVal ?condition ?value spec =
    let v = ConditionalLegendValueDef.make ?condition ?value () in
    let f enc = Encoding.{enc with opacity = Some (`Value v)} in
    specSet f spec

  let color =
    let setter clfd e = Encoding.{e with color = Some clfd} in
    clfdSet setter

  let colorRep =
    let setter clfd e = Encoding.{e with color = Some clfd} in
    clfdSetRep setter

  let colorVal ?condition ?value spec =
    let v = ConditionalLegendValueDef.make ?condition ?value () in
    let f enc = Encoding.{enc with color = Some (`Value v)} in
    specSet f spec


  type ctfdSetter =
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?format:string ->
    ?timeUnit:TimeUnit.t ->
    ?typ:Type.t ->
    D.field ->
    Spec.t -> Spec.t

  type ctfdRepSetter =
    ?aggregate:AggregateOp.t ->
    ?bin:[ `Bool of bool | `Params of BinParams.t ] ->
    ?condition:ConditionValueDef.t ->
    ?format:string ->
    ?timeUnit:TimeUnit.t ->
    typ:Type.t ->
    RepeatRef.t ->
    Spec.t -> Spec.t

  let ctfdSet (f : [`Field of ConditionalTextFieldDef.t | `Value of ConditionalTextValueDef.t] -> Encoding.t -> Encoding.t) : ctfdSetter =
    fun ?aggregate ?bin ?condition ?format ?timeUnit ?typ x spec ->
      let ctfd = conditionalTextFieldDef ?aggregate ?bin ?condition ?format ?timeUnit ?typ x in
      specSet (f ctfd) spec

  let ctfdSetRep (f : [`Field of ConditionalTextFieldDef.t | `Value of ConditionalTextValueDef.t] -> Encoding.t -> Encoding.t) : ctfdRepSetter =
    fun ?aggregate ?bin ?condition ?format ?timeUnit ~typ x spec ->
      let ctfd = `Field (ConditionalTextFieldDef.make ?aggregate ?bin ?condition ?format ?timeUnit ~typ ~field:(`Repeat x) ()) in
      specSet (f ctfd) spec

  let tooltip =
    let setter ctfd e = Encoding.{e with tooltip = Some ctfd} in
    ctfdSet setter

  let tooltipRep =
    let setter ctfd e = Encoding.{e with tooltip = Some ctfd} in
    ctfdSetRep setter

  let tooltipVal ?condition ?value spec =
    let v = ConditionalTextValueDef.make ?condition ?value () in
    let f enc = Encoding.{enc with tooltip = Some (`Value v)} in
    specSet f spec

  let text =
    let setter ctfd e = Encoding.{e with text = Some ctfd} in
    ctfdSet setter

  let textRep =
    let setter ctfd e = Encoding.{e with text = Some ctfd} in
    ctfdSetRep setter

  let textVal ?condition ?value spec =
    let v = ConditionalTextValueDef.make ?condition ?value () in
    let f enc = Encoding.{enc with text = Some (`Value v)} in
    specSet f spec

  let order ?aggregate ?bin ?sort ?timeUnit ?typ x spec =
    let o = orderFieldDef ?aggregate ?bin ?sort ?timeUnit ?typ x in
    let f enc = Encoding.{enc with order = Some (`Field o)} in
    specSet f spec

  let orderMulti ofds spec =
    let f enc = Encoding.{enc with order = Some (`Fields ofds)} in
    specSet f spec

  let detail ?aggregate ?bin ?timeUnit ?typ x spec =
    let o = fieldDef ?aggregate ?bin ?timeUnit ?typ x in
    let f enc = Encoding.{enc with detail = Some o} in
    specSet f spec

  let detailMulti fds spec =
    let f enc = Encoding.{enc with detail = Some (`Fields fds)} in
    specSet f spec

  let data_ : D.t option -> VegaLite.V2.Data.t option = function
    | None -> None
    | Some d -> Some (D.inline d)

  let repeat_ : repeat -> Repeat.t = function
    | Repeat.{row; column} -> Repeat.{
        row = Some (List.map D.fieldName row);
        column = Some (List.map D.fieldName column);
      }

  let unitSpec ?description ?height ?name ?selection ?title ?transform ?width ?encoding ?data mark =
    let e = match encoding with
      | None -> (Encoding.make ())
      | Some e -> e
    in
    CompositeUnitSpec.make ?description ?height ?name ?selection ?title ?transform ?width ?data:(data_ data) ~encoding:e ~mark ()

  let layerSpec ?description ?height ?name ?resolve ?title ?transform ?width ?data layer =
    LayerSpec.make ?description ?height ?name ?resolve ?title ?transform ?width ?data:(data_ data) ~layer ()

  let faceted ?description ?name ?resolve ?title ?transform ?data ~facet spec =
    `Faceted (FacetedSpec.make ?description ?name ?resolve ?title ?transform ?data:(data_ data) ~facet ~spec ())

  let hconcat ?description ?name ?resolve ?title ?transform ?data hconcat =
    `HConcat (HConcatSpec.make ?description ?name ?resolve ?title ?transform ?data:(data_ data) ~hconcat ())

  let vconcat ?description ?name ?resolve ?title ?transform ?data vconcat =
    `VConcat (VConcatSpec.make ?description ?name ?resolve ?title ?transform ?data:(data_ data) ~vconcat ())

  let repeat ?description ?name ?resolve ?title ?transform ?data ~repeat spec =
    `Repeat (RepeatSpec.make ?description ?name ?resolve ?title ?transform ?data:(data_ data) ~repeat:(repeat_ repeat) ~spec ())

  let simple ?description ?height:(h=`Int 395) ?name ?selection ?title ?transform ?width:(w=`Int 640) ?encoding ?data mark =
    `Unit (unitSpec ?description ~height:h ?name ?selection ?title ?transform ~width:w ?encoding ?data mark)

  let layer ?description ?height:(h=`Int 395) ?name ?resolve ?title ?transform ?width:(w=`Int 640) ?data layer =
    `Layer (layerSpec ?description ~height:h ?name ?resolve ?title ?transform ~width:w ?data layer)

  let facetize row column = function
    | Encoding.{x; y; x2; y2; tooltip; text; size; shape; order; opacity; detail; color} ->
      EncodingWithFacet.make ?x ?y ?x2 ?y2 ?tooltip ?text ?size ?shape ?order ?opacity ?detail ?color ?row ?column ()

  let finish ?padding ?config ?background ?autoResize ?rowFacet ?columnFacet spec = match spec with
    | `Unit CompositeUnitSpec.{width; transform; title; selection; name; mark; height; encoding; description; data} ->
      let encoding = facetize rowFacet columnFacet encoding in
      `Unit (TopLevelFacetedUnitSpec.make ?width ?transform ?title ?selection ?name ~mark ?height ~encoding ?description ?data ?padding ?config ?background ?autoResize ())

    | `Faceted FacetedSpec.{transform; title; spec; resolve; name; facet; description; data} ->
      `Faceted (TopLevelFacetedSpec.make ?transform ?title ~spec ?resolve ?name ~facet ?description ?data ?padding ?config ?background ?autoResize ())

    | `Layer LayerSpec.{width; transform; title; resolve; name; layer; height; description; data} ->
      `Layer (TopLevelLayerSpec.make ?width ?transform ?title ?resolve ?name ~layer ?height ?description ?data ?padding ?config ?background ?autoResize ())

    | `Repeat RepeatSpec.{transform; title; spec; resolve; repeat; name; description; data} ->
      `Repeat (TopLevelRepeatSpec.make ?transform ?title ~spec ?resolve ~repeat ?name ?description ?data ?padding ?config ?background ?autoResize ())

    | `HConcat HConcatSpec.{transform; title; resolve; name; hconcat; description; data} ->
      `HConcat (TopLevelHConcatSpec.make ?transform ?title ?resolve ?name ~hconcat ?description ?data ?padding ?config ?background ?autoResize ())

    | `VConcat VConcatSpec.{transform; title; resolve; name; vconcat; description; data} ->
      `VConcat (TopLevelVConcatSpec.make ?transform ?title ?resolve ?name ~vconcat ?description ?data ?padding ?config ?background ?autoResize ())
end


module Dynamic = Make(
  struct
    type column = [
        `Float of float array
      | `Int of int array
      | `String of string array
      | `Bool of bool array
      | `FloatOpt of float option array
      | `IntOpt of int option array
      | `StringOpt of string option array
      | `BoolOpt of bool option array
    ]
    type t = (string * column) list

    (* TODO: Unless a better dynamic data frame type presents itself,
       write connectors to https://math.umons.ac.be/anum/software/csv/Csv/index.html
       of_csv needs to try to parse more specific first then less specific, I guess,
       and it needs to be smartish about deciding which values are missing
    (* let to_csv (x : t) : string list list = []
       let of_csv (csv : string list list) : t = [] *)

      Also need of_yojson
    *)

    type field = string
    let defaultTyp _ = `Ordinal
    let fieldName s = s

    let inline (b : t) : VegaLite.V2.Data.t =

      let n =
        let reducer (sofar : int) ((_, c) : (string * column)) : int =
          let l = match c with
            | `Float a -> Array.length a
            | `Int a -> Array.length a
            | `String a -> Array.length a
            | `Bool a -> Array.length a
            | `FloatOpt a -> Array.length a
            | `IntOpt a -> Array.length a
            | `StringOpt a -> Array.length a
            | `BoolOpt a -> Array.length a
          in
          if l > sofar then l else sofar
        in
        List.fold_left reducer 0 b
      in

      let reducer (sofar : (string * Yojson.Safe.json) list array) ((k, v) : (string * column)) : (string * Yojson.Safe.json) list array =
        let getOrNull f a i =
          try
            f (Array.get a i)
          with _ -> `Null
        in
        let getOrNullOpt f a i =
          try
            match Array.get a i with
            | None -> `Null
            | Some x -> f x
          with _ -> `Null
        in

        match v with
        | `Float a ->
          let mapper i l = (k, getOrNull (fun f -> `Float f) a i) :: l in Array.mapi mapper sofar
        | `Int a ->
          let mapper i l = (k, getOrNull (fun f -> `Int f) a i) :: l in Array.mapi mapper sofar
        | `String a ->
          let mapper i l = (k, getOrNull (fun f -> `String f) a i) :: l in Array.mapi mapper sofar
        | `Bool a ->
          let mapper i l = (k, getOrNull (fun f -> `Bool f) a i) :: l in Array.mapi mapper sofar

        | `FloatOpt a ->
          let mapper i l = (k, getOrNullOpt (fun f -> `Float f) a i) :: l in Array.mapi mapper sofar
        | `IntOpt a ->
          let mapper i l = (k, getOrNullOpt (fun f -> `Int f) a i) :: l in Array.mapi mapper sofar
        | `StringOpt a ->
          let mapper i l = (k, getOrNullOpt (fun f -> `String f) a i) :: l in Array.mapi mapper sofar
        | `BoolOpt a ->
          let mapper i l = (k, getOrNullOpt (fun f -> `Bool f) a i) :: l in Array.mapi mapper sofar

      in
      let jsons = List.fold_left reducer (Array.make n []) b
        |> Array.map (fun l -> `Assoc l)
        |> Array.to_list
      in
      `Inline (VegaLite.V2.InlineData.make ~values:(`Jsons jsons) ())


  end)
